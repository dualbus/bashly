#!/usr/bin/env bash
log__basic () 
{ 
    typeset argument;
    for argument in "$@";
    do
        printf '%s: %s\n' "${BASH_SOURCE##*/}" "$argument";
    done
}
log__debug () 
{ 
    typeset debug_level log_level;
    shift 2;
    if ((log_level >= debug_level)); then
        log__with_type DEBUG "$@";
    fi
}
log__error () 
{ 
    log__with_type ERROR "$@"
}
log__info () 
{ 
    log__with_type INFO "$@"
}
log__warning () 
{ 
    log__with_type WARNING "$@"
}
log__with_type () 
{ 
    typeset type=$1 argument;
    shift;
    for argument in "$@";
    do
        log__basic "$type: $argument" 1>&2;
    done
}

common__die () 
{ 
    typeset exit_status=$2;
    log__error "$1";
    exit "${exit_status:-1}"
}

object__new () 
{ 
    typeset class_description=$1 input_properties=$2;
    typeset field;
    typeset name;
    typeset value;
    typeset class;
    typeset -a fields;
    typeset -A properties;
    IFS=';' read -ra fields <<< "$class_description";
    for field in "${fields[@]}";
    do
        [[ -n $field ]] || return 1;
        properties["$field"]=y;
    done;
    IFS=';' read -ra fields <<< "$input_properties";
    for field in "${fields[@]}";
    do
        IFS=':' read -rd '' name value <<< "$field";
        value=${value%'
'};
        [[ -n "${properties["$name"]+set}" ]] || { 
            printf -- '-%s:%s\0' "$name" "$value";
            return 2
        };
        printf '%s:%s\0' "$name" "$value";
    done
}

cmdline__arguments () 
{ 
    :  <<EOD
  cmdline__arguments 

  env vars:

  - errors_not_fatal
  - dashdash_not_special
EOD

    typeset key
    typeset value;
    typeset shift;
    typeset argument;
    typeset options;
    typeset stop_parsing;
    typeset return_code;
    IFS=: read -rd '' shift options < <(cmdline__p__parse_descriptions "$@") || return;
    shift "${shift:-0}";
    if [[ $1 = '--' ]]; then
        shift;
    else
        return 2;
    fi;
    cmdline__p__consume_arguments "$@"
}
cmdline__help () 
{ 
    :
}
cmdline__p__arguments__long () 
{ 
    typeset long;
    typeset name;
    typeset arguments;
    typeset i;
    typeset -a options;
    typeset -A arguments_table;
    typeset -A name_table;
    IFS=';' read -ra options <<< "$1";
    shift;
    for option in "${options[@]}";
    do
        IFS=':' read -r name _ long arguments <<< "$option";
        arguments_table["$long"]=$arguments;
        name_table["$long"]=$name;
    done;
    [[ $1 = --[!-]* ]] || return 1;
    [[ -n ${arguments_table["${1#--}"]+set} ]] || return 1;
    [[ -n ${name_table["${1#--}"]+set} ]] || return 1;
    arguments=${arguments_table["${1#--}"]};
    name=${name_table["${1#--}"]};
    shift;
    ((arguments <= $#)) || return 1;
    printf %s "$((arguments + 1))";
    if ((arguments > 0)); then
        for ((i = 1; i <= arguments; i++))
        do
            printf '%s:%s\0' "$name" "${!i}";
        done;
    else
        printf '%s\0' "$name";
    fi 1>&3
}
cmdline__p__arguments__short () 
{ 
    typeset short;
    typeset name;
    typeset arguments;
    typeset i;
    typeset -a options;
    typeset -A arguments_table;
    typeset -A name_table;
    IFS=';' read -ra options <<< "$1";
    shift;
    for option in "${options[@]}";
    do
        IFS=':' read -r name short _ arguments <<< "$option";
        arguments_table["$short"]=$arguments;
        name_table["$short"]=$name;
    done;
    [[ $1 = -[!-] ]] || return 1;
    [[ -n ${arguments_table["${1#-}"]+set} ]] || return 1;
    [[ -n ${name_table["${1#-}"]+set} ]] || return 1;
    arguments=${arguments_table["${1#-}"]};
    name=${name_table["${1#-}"]};
    shift;
    ((arguments <= $#)) || return 1;
    printf %s "$((arguments + 1))";
    if ((arguments > 0)); then
        for ((i = 1; i <= arguments; i++))
        do
            printf '%s:%s\0' "$name" "${!i}";
        done;
    else
        printf '%s\0' "$name";
    fi 1>&3
}
cmdline__p__arguments__short_composed () 
{ 
    typeset options_description=$1;
    typeset short;
    typeset rest;
    typeset arguments;
    typeset shift;
    typeset flag;
    typeset i;
    typeset -a options;
    typeset -a flags;
    typeset -a last_option;
    typeset -A arguments_table;
    IFS=';' read -ra options <<< "$options_description";
    shift;
    for option in "${options[@]}";
    do
        IFS=':' read -r name short _ arguments <<< "$option";
        arguments_table["$short"]=$arguments;
    done;
    rest=$1;
    shift;
    while [[ -n $rest ]]; do
        short=${rest#-} rest=${short#?} short=${short%"$rest"};
        [[ -n ${arguments_table["$short"]+set} ]] || return 1;
        arguments=${arguments_table["$short"]};
        if ((arguments == 0)); then
            flags+=("-$short");
        else
            if ((arguments > 0)) && [[ -n $rest ]]; then
                last_option=("-$short" "$rest" "$@") shift=$arguments;
                break;
            else
                if ((arguments > 0)); then
                    last_option=("-$short" "$@") shift=$((arguments + 1));
                    break;
                else
                    return 1;
                fi;
            fi;
        fi;
    done;
    if [[ -n $last_option ]]; then
        printf %s $shift;
    else
        printf %s 1;
    fi;
    for flag in "${flags[@]}";
    do
        cmdline__p__arguments__short "$options_description" "$flag" > /dev/null;
    done;
    cmdline__p__arguments__short "$options_description" "${last_option[@]}" > /dev/null
}
cmdline__p__consume_arguments () 
{ 
    typeset options=$1;
    shift;
    typeset argument;
    typeset stop_parsing;
    typeset helper;
    while (($# > 0)); do
        if [[ -n $stop_parsing ]]; then
            printf '@:%s\0' "$1";
            shift;
            continue;
        fi;
        helper=;
        case $1 in 
            -[!-])
                helper=cmdline__p__arguments__short
            ;;
            -[!-]*)
                helper=cmdline__p__arguments__short_composed
            ;;
            --[!-]*)
                if [[ $1 = --+([!=-])=* ]]; then
                    IFS='=' read -rd '' key value <<< "$1";
                    value=${value%'
'};
                    shift 1;
                    set -- "$key" "$value" "$@";
                fi;
                helper=cmdline__p__arguments__long
            ;;
            --)
                stop_parsing=y
            ;;
            *)
                printf '@:%s\0' "$1"
            ;;
        esac;
        if [[ -n $helper ]]; then
            { 
                shift=$("$helper" "$options" "$@") || return 1
            } 3>&1;
            shift "$((shift))";
        else
            shift;
        fi;
    done
}
cmdline__p__parse_descriptions () 
{ 
    typeset option_description;
    typeset option_object;
    typeset key;
    typeset value;
    typeset shift;
    typeset argument;
    typeset name;
    typeset short;
    typeset long;
    typeset -a option_descriptions;
    option_object='name;short;long;arguments;help';
    shift=0;
    for option_description in "$@";
    do
        [[ $option_description = '--' ]] && break;
        ((shift++));
        name= short= long= arguments=0;
        while IFS=: read -rd '' key value; do
            case $key in 
                -*)
                    return 1
                ;;
                name | short | long | arguments)
                    typeset "$key=$value"
                ;;
            esac;
        done < <(object__new "$option_object" "$option_description");
        option_descriptions+=("$name:$short:$long:$arguments");
    done;
    ( IFS=';';
    printf %s:%s "$shift" "${option_descriptions[*]}" )
}

emit_line () 
{ 
    typeset line_number=$1 line=$2;
    typeset LC_CTYPE=C;
    : trailing_newline;
    : opt_number_nonblank opt_show_ends opt_number;
    : opt_squeeze_blank opt_show_tabs opt_show_nonprinting;
    if [[ -n $opt_show_tabs ]]; then
        line=${line//'	'/^I};
    fi;
    if [[ -n $opt_show_nonprinting ]]; then
        IFS= read -r line < <(escape_line "$line");
    fi;
    if [[ -n $opt_number ]]; then
        printf '% 6d\t%s' "$line_number" "$line";
    else
        if [[ -n $opt_number_nonblank && -n $line ]]; then
            printf '% 6d\t%s' "$line_number" "$line";
        else
            if [[ -n $opt_number_nonblank ]]; then
                :;
            else
                printf '%s' "$line";
            fi;
        fi;
    fi;
    if [[ -n $opt_show_ends ]]; then
        printf '$';
    fi;
    if [[ -n $trailing_newline || -n $opt_show_ends ]]; then
        printf '\n';
    fi
}
escape_line () 
{ 
    typeset line=$1;
    typeset i character escaped_line;
    typeset -A replacements=(['']='^A' ['']='^B' ['']='^C' ['']='^D' ['']='^E' ['']='^F' ['']='^G' ['']='^H' ['	']='^I' ['']='^K' ['']='^L' ['']='^M' ['']='^N' ['']='^O' ['']='^P' ['']='^Q' ['']='^R' ['']='^S' ['']='^T' ['']='^U' ['']='^V' ['']='^W' ['']='^X' ['']='^Y' ['']='^Z' ['']='^[' ['']='^\' ['']='^]' ['']='^^' ['']='^_' ['']='^?' ['€']='M-^@' ['']='M-^A' ['‚']='M-^B' ['ƒ']='M-^C' ['„']='M-^D' ['…']='M-^E' ['†']='M-^F' ['‡']='M-^G' ['ˆ']='M-^H' ['‰']='M-^I' ['Š']='M-^J' ['‹']='M-^K' ['Œ']='M-^L' ['']='M-^M' ['Ž']='M-^N' ['']='M-^O' ['']='M-^P' ['‘']='M-^Q' ['’']='M-^R' ['“']='M-^S' ['”']='M-^T' ['•']='M-^U' ['–']='M-^V' ['—']='M-^W' ['˜']='M-^X' ['™']='M-^Y' ['š']='M-^Z' ['›']='M-^[' ['œ']='M-^\' ['']='M-^]' ['ž']='M-^^' ['Ÿ']='M-^_' [' ']='M- ' ['¡']='M-!' ['¢']='M-"' ['£']='M-#' ['¤']='M-$' ['¥']='M-%' ['¦']='M-&' ['§']="M-'" ['¨']='M-(' ['©']='M-)' ['ª']='M-*' ['«']='M-+' ['¬']='M-,' ['­']='M--' ['®']='M-.' ['¯']='M-/' ['°']='M-0' ['±']='M-1' ['²']='M-2' ['³']='M-3' ['´']='M-4' ['µ']='M-5' ['¶']='M-6' ['·']='M-7' ['¸']='M-8' ['¹']='M-9' ['º']='M-:' ['»']='M-;' ['¼']='M-<' ['½']='M-=' ['¾']='M->' ['¿']='M-?' ['À']='M-@' ['Á']='M-A' ['Â']='M-B' ['Ã']='M-C' ['Ä']='M-D' ['Å']='M-E' ['Æ']='M-F' ['Ç']='M-G' ['È']='M-H' ['É']='M-I' ['Ê']='M-J' ['Ë']='M-K' ['Ì']='M-L' ['Í']='M-M' ['Î']='M-N' ['Ï']='M-O' ['Ð']='M-P' ['Ñ']='M-Q' ['Ò']='M-R' ['Ó']='M-S' ['Ô']='M-T' ['Õ']='M-U' ['Ö']='M-V' ['×']='M-W' ['Ø']='M-X' ['Ù']='M-Y' ['Ú']='M-Z' ['Û']='M-[' ['Ü']='M-\' ['Ý']='M-]' ['Þ']='M-^' ['ß']='M-_' ['à']='M-`' ['á']='M-a' ['â']='M-b' ['ã']='M-c' ['ä']='M-d' ['å']='M-e' ['æ']='M-f' ['ç']='M-g' ['è']='M-h' ['é']='M-i' ['ê']='M-j' ['ë']='M-k' ['ì']='M-l' ['í']='M-m' ['î']='M-n' ['ï']='M-o' ['ð']='M-p' ['ñ']='M-q' ['ò']='M-r' ['ó']='M-s' ['ô']='M-t' ['õ']='M-u' ['ö']='M-v' ['÷']='M-w' ['ø']='M-x' ['ù']='M-y' ['ú']='M-z' ['û']='M-{' ['ü']='M-|' ['ý']='M-}' ['þ']='M-~' ['ÿ']='M-^?');
    for ((i = 0; i < ${#line}; i++))
    do
        character=${line:i:1};
        if [[ ! -n $character ]]; then
            escaped_line+='^@';
        else
            escaped_line+=${replacements["$character"]-"$character"};
        fi;
    done;
    printf %s "$escaped_line"
}
main () 
{ 
    :  <<EOD
  Sample option parsing and automated help generation. This utility
  attempts to imitate GNU cat.

  This shows some of the short-comings of cmdline__*, namely that
  help strings look a bit ugly when they're too long (unless you're
  ok with not wrapping to 80 characters)

  It's also a bit easy to get confused between all these special
  characters, i.e. :'s and ='s.

  Also, it's not a true cat, because it cannot handle NUL bytes (and
  I will not attempt to solve it)
EOD

    typeset type value file line line_number
    typeset opt_number_nonblank opt_show_ends opt_number;
    typeset opt_squeeze_blank opt_show_tabs opt_show_nonprinting;
    typeset -a files;
    typeset version='gcat 0.9';
    typeset -a options=('name:show_all;short:A;long:show-all;help:equivalent to -vET' 'name:number_nonblank;short:b;long:number-nonblank;help:number ''nonempty output lines, overrides -n' 'name:show_nonprinting_ends;short:e;help:equivalent to -vE' 'name:show_ends;short:E;long:show-ends;help:display $ at end ''of each line' 'name:number;short:n;long:number;help:number all output lines' 'name:squeeze_blank;short:s;long:squeeze-blank;help:suppress ''repeated empty output lines' 'name:show_nonprinting_tabs;short:t;help:equivalent to -vT' 'name:show_tabs;short:T;long:show-tabs;help:display TAB ''characters as ^I' 'name:unknown;short:u;help:(ignored)' 'name:show_nonprinting;short:v;long:show-nonprinting;help:use ^ ''and M- notation, except for LFD and TAB' 'name:help;long:help;help:display this help and exit' 'name:version;long:version;help:output version information and exit');
    while IFS=: read -rd '' type value; do
        case $type in 
            @)
                if [[ $value = - ]]; then
                    files+=("/dev/stdin");
                else
                    files+=("$value");
                fi
            ;;
            -)
                common__die "unknown option ''$value''"
            ;;
            show_all)
                opt_show_ends=y opt_show_tabs=y opt_show_nonprinting=y
            ;;
            number_nonblank)
                opt_number_nonblank=y
            ;;
            show_nonprinting_ends)
                opt_show_ends=y opt_show_nonprinting=y
            ;;
            show_ends)
                opt_show_ends=y
            ;;
            number)
                opt_number=y
            ;;
            squeeze_blank)
                opt_squeeze_blank=y
            ;;
            show_nonprinting_tabs)
                opt_show_tabs=y opt_show_nonprinting=y
            ;;
            show_tabs)
                opt_show_tabs=y
            ;;
            show_nonprinting)
                opt_show_nonprinting=y
            ;;
            help)
                cmdline__help "${options[@]}";
                return 0
            ;;
            version)
                printf 'gcat\n';
                return 0
            ;;
        esac;
    done < <(cmdline__arguments "${options[@]}" -- "$@");
    ((${#files[@]})) || files=(/dev/stdin);
    for file in "${files[@]}";
    do
        while IFS= read -r line; do
            if [[ -n $opt_number_nonblank && -n $line ]]; then
                ((line_number++));
            else
                if [[ -n $opt_number ]]; then
                    ((line_number++));
                fi;
            fi;
            trailing_newline=y emit_line "$line_number" "$line";
        done < "$file";
        [[ -n $line ]] && { 
            ((line_number++));
            emit_line "$line_number" "$line"
        };
    done
}
main "$@"
